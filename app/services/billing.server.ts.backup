/**
 * Billing Service for Spector App (Managed Pricing)
 * 
 * With Managed Pricing, Shopify handles all billing operations.
 * This service only checks subscription status from Shopify.
 * 
 * - Checks subscription status via GraphQL
 * - Controls app access based on active subscription
 * - Merchants manage billing through Shopify admin
 */

import prisma from "~/db.server";

// GraphQL query to check active subscriptions from Shopify
const GET_ACTIVE_SUBSCRIPTIONS_QUERY = `#graphql
  query GetActiveSubscriptions {
    currentAppInstallation {
      activeSubscriptions {
        id
        name
        status
        test
        currentPeriodEnd
        trialDays
        createdAt
        lineItems {
          plan {
            pricingDetails {
              ... on AppRecurringPricing {
                price {
                  amount
                  currencyCode
                }
                interval
              }
            }
          }
        }
      }
    }
  }
`;

interface ShopifySubscription {
  id: string;
  name: string;
  status: string;
  currentPeriodEnd?: string;
  trialDays?: number;
  createdAt: string;
  test: boolean;
  lineItems: Array<{
    plan: {
      pricingDetails: {
        price: {
          amount: string;
          currencyCode: string;
        };
        interval: string;
      };
    };
  }>;
}

/**
 * Initialize subscription for a new shop installation
 * Creates database record with trial period
 */
export async function initializeSubscription(shop: string): Promise<{
  subscription: any;
  isNew: boolean;
}> {
  // Check if subscription already exists
  let subscription = await prisma.subscription.findUnique({
    where: { shop },
  });

  if (subscription) {
    return { subscription, isNew: false };
  }

  // Create new subscription with trial
  const trialEndsAt = calculateTrialEndDate();
  
  subscription = await prisma.subscription.create({
    data: {
      shop,
      plan: BILLING_CONFIG.PLAN_ID,
      status: 'trialing',
      trialStartedAt: new Date(),
      trialEndsAt,
      isTrialUsed: false,
      price: BILLING_CONFIG.MONTHLY_PRICE,
      currency: BILLING_CONFIG.CURRENCY,
    },
  });

  console.log(`[Billing] Initialized trial for shop: ${shop}, expires: ${trialEndsAt.toISOString()}`);
  
  return { subscription, isNew: true };
}

/**
 * Check if shop has active access (trial or paid)
 */
export async function checkSubscriptionAccess(shop: string): Promise<{
  hasAccess: boolean;
  subscription: any;
  reason?: string;
}> {
  const subscription = await prisma.subscription.findUnique({
    where: { shop },
  });

  if (!subscription) {
    return {
      hasAccess: false,
      subscription: null,
      reason: 'NO_SUBSCRIPTION',
    };
  }

  const hasAccess = hasActiveSubscription(
    subscription.status as SubscriptionStatus,
    subscription.trialEndsAt
  );

  if (!hasAccess) {
    const now = new Date();
    if (subscription.status === 'trialing' && now > subscription.trialEndsAt) {
      return {
        hasAccess: false,
        subscription,
        reason: 'TRIAL_EXPIRED',
      };
    }
    return {
      hasAccess: false,
      subscription,
      reason: subscription.status === 'cancelled' ? 'CANCELLED' : 'NO_ACTIVE_PLAN',
    };
  }

  return {
    hasAccess: true,
    subscription,
  };
}

/**
 * Create a recurring charge with Shopify
 * Returns confirmation URL for merchant to approve
 */
export async function createRecurringCharge(
  graphql: any,
  shop: string,
  returnUrl: string
): Promise<{
  confirmationUrl: string | null;
  error: string | null;
  chargeId: string | null;
}> {
  try {
    const response = await graphql(CREATE_RECURRING_CHARGE_MUTATION, {
      variables: {
        name: BILLING_CONFIG.CHARGE_CONFIG.name,
        price: BILLING_CONFIG.CHARGE_CONFIG.price,
        currencyCode: BILLING_CONFIG.CHARGE_CONFIG.currencyCode,
        interval: BILLING_CONFIG.CHARGE_CONFIG.interval,
        trialDays: BILLING_CONFIG.CHARGE_CONFIG.trialDays,
        test: BILLING_CONFIG.CHARGE_CONFIG.test,
        returnUrl,
      },
    });

    const data = await response.json();
    const result = data.data?.appSubscriptionCreate;

    if (result?.userErrors?.length > 0) {
      const errorMessage = result.userErrors.map((e: any) => e.message).join(', ');
      console.error(`[Billing] Error creating charge: ${errorMessage}`);
      return {
        confirmationUrl: null,
        error: errorMessage,
        chargeId: null,
      };
    }

    const chargeId = result?.appSubscription?.id;
    const confirmationUrl = result?.confirmationUrl;

    if (!confirmationUrl || !chargeId) {
      return {
        confirmationUrl: null,
        error: 'Failed to get confirmation URL',
        chargeId: null,
      };
    }

    // Update subscription with charge ID
    await prisma.subscription.update({
      where: { shop },
      data: {
        shopifyChargeId: chargeId,
        status: 'trialing', // Will be updated to 'active' after merchant approval
        updatedAt: new Date(),
      },
    });

    console.log(`[Billing] Created charge for ${shop}, ID: ${chargeId}`);

    return {
      confirmationUrl,
      error: null,
      chargeId,
    };
  } catch (error) {
    console.error('[Billing] Error creating recurring charge:', error);
    return {
      confirmationUrl: null,
      error: error instanceof Error ? error.message : 'Unknown error',
      chargeId: null,
    };
  }
}

/**
 * Sync subscription status from Shopify
 */
export async function syncSubscriptionStatus(
  graphql: any,
  shop: string
): Promise<{
  success: boolean;
  subscription: any;
  error?: string;
}> {
  try {
    const response = await graphql(GET_ACTIVE_SUBSCRIPTIONS_QUERY);
    const data = await response.json();
    
    const activeSubscriptions = data.data?.currentAppInstallation?.activeSubscriptions || [];

    // Find our app's subscription
    const shopifySubscription = activeSubscriptions.find(
      (sub: ShopifySubscription) => sub.name === BILLING_CONFIG.CHARGE_CONFIG.name
    );

    const localSubscription = await prisma.subscription.findUnique({
      where: { shop },
    });

    if (!localSubscription) {
      console.error(`[Billing] No local subscription found for ${shop}`);
      return {
        success: false,
        subscription: null,
        error: 'No local subscription',
      };
    }

    // Map Shopify status to our status
    let status: SubscriptionStatus = localSubscription.status as SubscriptionStatus;
    
    if (shopifySubscription) {
      const shopifyStatus = shopifySubscription.status.toUpperCase();
      
      if (shopifyStatus === 'ACTIVE') {
        status = 'active';
      } else if (shopifyStatus === 'CANCELLED' || shopifyStatus === 'DECLINED') {
        status = 'cancelled';
      } else if (shopifyStatus === 'FROZEN') {
        status = 'frozen';
      } else if (shopifyStatus === 'PENDING') {
        status = 'trialing';
      }
    } else {
      // No active subscription in Shopify
      const now = new Date();
      if (now > localSubscription.trialEndsAt) {
        status = 'expired';
      }
    }

    // Update local subscription
    const updatedSubscription = await prisma.subscription.update({
      where: { shop },
      data: {
        status,
        lastCheckedAt: new Date(),
        ...(shopifySubscription?.id && { shopifyChargeId: shopifySubscription.id }),
        ...(shopifySubscription?.currentPeriodEnd && {
          currentPeriodEnd: new Date(shopifySubscription.currentPeriodEnd),
        }),
      },
    });

    console.log(`[Billing] Synced subscription for ${shop}, status: ${status}`);

    return {
      success: true,
      subscription: updatedSubscription,
    };
  } catch (error) {
    console.error('[Billing] Error syncing subscription:', error);
    return {
      success: false,
      subscription: null,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Cancel subscription
 */
export async function cancelSubscription(
  graphql: any,
  shop: string
): Promise<{
  success: boolean;
  error?: string;
}> {
  try {
    const subscription = await prisma.subscription.findUnique({
      where: { shop },
    });

    if (!subscription?.shopifyChargeId) {
      console.warn(`[Billing] No Shopify charge ID for ${shop}, marking as cancelled locally`);
      await prisma.subscription.update({
        where: { shop },
        data: {
          status: 'cancelled',
          cancelledAt: new Date(),
          updatedAt: new Date(),
        },
      });
      return { success: true };
    }

    // Cancel in Shopify
    const response = await graphql(CANCEL_SUBSCRIPTION_MUTATION, {
      variables: {
        id: subscription.shopifyChargeId,
      },
    });

    const data = await response.json();
    const result = data.data?.appSubscriptionCancel;

    if (result?.userErrors?.length > 0) {
      const errorMessage = result.userErrors.map((e: any) => e.message).join(', ');
      console.error(`[Billing] Error cancelling subscription: ${errorMessage}`);
      return {
        success: false,
        error: errorMessage,
      };
    }

    // Update local record
    await prisma.subscription.update({
      where: { shop },
      data: {
        status: 'cancelled',
        cancelledAt: new Date(),
        updatedAt: new Date(),
      },
    });

    console.log(`[Billing] Cancelled subscription for ${shop}`);

    return { success: true };
  } catch (error) {
    console.error('[Billing] Error cancelling subscription:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Mark subscription as active after approval
 */
export async function activateSubscription(
  shop: string,
  chargeId: string
): Promise<{
  success: boolean;
  subscription: any;
}> {
  const subscription = await prisma.subscription.update({
    where: { shop },
    data: {
      status: 'active',
      shopifyChargeId: chargeId,
      billingStartedAt: new Date(),
      currentPeriodStart: new Date(),
      updatedAt: new Date(),
    },
  });

  console.log(`[Billing] Activated subscription for ${shop}`);

  return {
    success: true,
    subscription,
  };
}
